<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Windows version 5.2.0">
  <title>HOWTO-grm</title>
  <meta http-equiv="content-type" content=
  "text/html; charset=utf-8">
</head>
<body style="width: 90%; margin: 2em auto; font-size: 20px">
  <h1 align="center">HOWTO-grm</h1>
  <h1 align="center"></h1>
  <h1 align="center"><small>id est</small></h1>
  <h1 align="center"></h1>
  <h1 align="center">How to write a PolyGen grammar</h1>
  <h2><br></h2>
  <h2>Index</h2><b>1.0</b> <a href=
  "#1.0_Cos%E8_una_grammatica">What is a grammar?</a><br>
  <br>
  <b>&nbsp; &nbsp; &nbsp;1.0.1</b> <a href=
  "#1.0.1_Sottoproduzioni">Subproductions</a><br>
  <b>&nbsp; &nbsp; &nbsp;1.0.2</b> <a href=
  "#1.0.2_Sottoproduzioni_opzionali">Optional
  subproductions</a><br>
  <b>&nbsp; &nbsp; &nbsp;1.0.3</b> <a href=
  "#1.0.3_Commenti">Comments</a><br>
  <br>
  <br>
  <b>2.0</b> <a href="#2.0_Caratteristiche_avanzate">Advanced
  features</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b><br></b> <b>&nbsp; &nbsp;
  &nbsp;</b><b>2.0.1</b> <a href=
  "#2.0.1_Concatenazione">Concatenation</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.0.2</b> <a href=
  "#2.0.2_Epsilon">Epsilon</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.0.3</b> <a href=
  "#2.0.3_Controllo_della_probabilit%E0_di_una">Controlling the
  probability of a production</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.0.4</b> <a href=
  "#2.0.4_Unfolding">Unfolding</a><br>
  <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;<b>2.0.4.1</b> <a href=
  "#2.0.4.1_Di_simboli_non_terminali">Non-terminal symbols</a><br>
  <b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0.4.2</b> <a href=
  "#2.0.4.2_Di_sottoproduzioni">Subproductions<br></a>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</b>
  <b>2.0.4.3</b> <a href=
  "#2.0.4.3_Di_sottoproduzioni_opzionali">Optional
  subproductions</a><br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;<b>2.0.4.4</b> <a href=
  "#2.0.4.4_Di_sottoproduzioni_permutabili">Permutable
  subproductions</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;
  2.0.4.5</b> <a href="#2.0.4.5_Di_sottoproduzioni_soggette">Deeply
  unfolded subproductions</a><br>
  <b><br>
  &nbsp; &nbsp; &nbsp;2.0.5</b> <a href=
  "#2.0.5_Attributi">Attributes</a><br>
  <b>&nbsp; &nbsp; &nbsp;<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0.5.1</b> <a href=
  "#2.0.5.1_Etichette_e_selezione">Labels and selection</a><br>
  &nbsp; &nbsp; &nbsp; <b>&nbsp; &nbsp; &nbsp; &nbsp;2.0.5.2</b>
  <a href="#2.0.5.2_Selezione_multipla">Multiple selection</a><br>
  <br>
  &nbsp; &nbsp; &nbsp; <b>2.0.6</b> <a href=
  "#2.0.6_Maiuscole">Capitalization</a><br>
  &nbsp;&nbsp;&nbsp; &nbsp; <b>2.0.7</b> <a href=
  "#2.0.7_Permutazioni">Permutation</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;2.0.8</b> <a href=
  "#2.0.8_Unfolding_in_profondit%E0">Deep unfolding</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;2.0.9</b> <a href=
  "#2.0.9_Folding">Folding</a><br>
  <br>
  <br>
  <b>2.1</b> <a href="#2.1_Tecniche_avanzate">Advanced
  techniques</a><br>
  <br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.1.1</b> <a href=
  "#2.1.1_Ricorsione">Recursion</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.1.2</b> <a href=
  "#2.1.2_Ragruppamento">Grouping</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.1.3</b> <a href=
  "#2.1.3_Controllo_della_probabilt%E0_di_una">Controlling the
  probabilty of an optional subproduction</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>2.1.4</b> <a href=
  "#2.1.4_Reset_di_una_selezione">Selection reset</a><br>
  <br>
  <br>
  <b>3.0</b> <a href=
  "#3.0_Controllo_statico_di_una_grammatica">Static checking of
  grammars</a><br>
  <br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>3.0.1</b> <a href=
  "#3.0.1_Errori">Errors</a><br>
  <br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>&nbsp; &nbsp; &nbsp;</b>
  <b>&nbsp;3.0.1.1</b> <a href=
  "#3.0.1.1_Inesistenza_di_simboli_non">Undefined non-terminal
  simbols</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>&nbsp; &nbsp; &nbsp;</b>
  <b>&nbsp;</b><b>3.0.1.2</b> <a href=
  "#3.0.1.2_Ricorsioni_cicliche_e">Cyclic recursion and
  non-termination</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>&nbsp; &nbsp; &nbsp;</b>
  <b>&nbsp;</b><b>3.0.1.3</b> <a href=
  "#3.0.1.3_Unfolding_ricorsivi">Recursive unfolding</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>&nbsp; &nbsp; &nbsp;</b>
  <b>&nbsp;</b><b>3.0.1.4</b> <a href=
  "#3.0.1.4_Epsilon-produzioni">Epsilon-productions</a><br>
  <b>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
  &nbsp;</b><b>3.0.1.5</b> <a href=
  "#3.0.1.5_Ridefinizione_di_simboli_non_terminali">Overriding of
  non-terminal symbols</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
  3.0.1.6</b> <a href="#3.0.1.6_Carattere_sconosciuto">Illegal
  character</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
  3.0.1.7</b> <a href="#3.0.1.7_Token_inaspettato">Unexpected
  token</a><br>
  <br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>3.0.2</b> <a href=
  "#3.0.2_Warning">Warnings</a><br>
  <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp; <b>3.0.2.0</b> <a href="#3.0.2.0_Livello_0">Level
  0</a><br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
  &nbsp;<b>3.0.2.1</b> <a href="#3.0.2.0_Livello_1">Level 1</a><br>
  <br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</b><b>3.0.2.1.1</b>
  <a href="#3.0.2.1_Inesistenza_del_simbolo_I">Undefined symbol
  <code>I</code></a><br>
  <b>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;</b> <b>&nbsp; &nbsp;
  &nbsp;</b> <b>&nbsp;</b> <b>&nbsp; &nbsp; 3.0.2.1.2</b> <a href=
  "#3.0.2.2_Potenziali_epsilon-produzioni">Potential
  epsilon-productions</a><br>
  <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
  &nbsp;<b>3.0.2.2</b> <a href="#3.0.2.0_Livello_2">Level 2</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;&nbsp; 3.0.2.2.1</b>&nbsp;<a href=
  "#3.0.2.2_Permutazione_inutile">Useless permutation</a><a href=
  "file:///home/manta/develop/polygen/0.8.1/ita/HOWTO-grm.html#3.0.2.2.1_Permutazione_inutile"></a><br>

  <b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;&nbsp;</b> <b>3.0.2.2.2</b> <a href=
  "#3.0.2.2.2_Potenziale_ricorsione_ciclica">Potential cyclic
  recursion</a><b><br></b><br>
  <br>
  <b>4.0</b> <a href="#4.0_Appendice">Appendix</a><br>
  <br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>4.1.1</b> <a href=
  "#4.1.1_Sintassi_concreta">Concrete syntax</a><br>
  <b>&nbsp;&nbsp;&nbsp; &nbsp;4.1.2</b> <a href=
  "#4.1.2_Sintassi_astratta">Abstract syntax</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>4.1.3</b> <a href=
  "#4.1.3_Regole_lessicali">Lexical rules</a><br>
  <b>&nbsp; &nbsp; &nbsp;</b><b>4.1.4</b> <a href=
  "#4.1.4_Caratteri_escape">Escape sequences</a><br>
  &nbsp; &nbsp; &nbsp; <b>4.1.5</b> <a href=
  "#4.1.5_Regole_di_traduzione">Translation rules</a><br>
  <br>
  <br>
  <br>
  <br>
  <h2><a name="1.0_Cosè_una_grammatica" id=
  "1.0_Cosè_una_grammatica"></a>1.0 What is a grammar?</h2>A
  grammar is an ASCII text file providing the definition of the
  syntactical structure and terms used by the program to build
  sentences. <i>PolyGen</i> is able to interpret a language
  designed for defining <i>type-2</i> grammars (according to
  Chomsky classification) consisting in an extension of the <i>BNF
  (Backus Naur Form)</i> - a very simple and common form for the
  description of the syntax of a language.<br>
  <br>
  A definition consists in specifying for a given symbol a set of
  productions interleaved by a&nbsp;<b>pipe</b> <font color=
  "#CC0000"><code>|</code></font> and followed by a
  <b>semicolon</b> <b><code><font color=
  "#CC0000">;</font></code></b> , which acts as terminator:<br>
  <br>
  <b><samp>EXAMPLE</samp></b><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> the apple <font color="#CC0000">|</font> an
  orange <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <b><samp>PRODUCES<br></samp></b> <code><br>
  the apple<br>
  an orange<br></code><br>
  <br>
  <br>
  Such definition of symbol&nbsp;<code><font color=
  "#996633">S</font></code> (said <b>non-terminal</b>) allows the
  generation of symbols <code>the apple</code> as well as <code>an
  orange</code> (said <b>terminal</b>).<br>
  The probability for the output&nbsp;<code>the apple</code> to be
  generated is equal to 1 every 3 times; and the same
  for&nbsp;<code>an orange</code>: thus, when 2 productions occur,
  we have 1 in 2 chances each; when 5 occur, we have 1 in 5,
  etc.<br>
  <br>
  You're allowed to define several non-terminal symbols and
  reference them from any productions, in order to let more complex
  sentences be generated:<br>
  <br>
  <b><samp>EXAMPLE</samp></b><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> the <font color="#996633">Animal</font> is
  eating a <font color="#996633">Animal</font> <font color=
  "#CC0000">;</font><br>
  <br>
  <font color="#996633">Animale</font> <font color=
  "#CC0000">::=</font> cat <font color="#CC0000">|</font> dog
  <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <b><samp>PRODUCES<br></samp></b> <code><br>
  the cat is eating a cat<br>
  the cat is eating a dog<br>
  the dog is eating a cat<br>
  the dog is eating a dog</code><br>
  <br>
  ecc.<br>
  <br>
  <br>
  <small><b>Note:</b> <i>PolyGen</i> uses by default the
  non-terminal symbol <code><font color="#996633">S</font></code>
  as the starting one: every grammar must therefore define it at
  least unless another starting symbol has been specified as
  argument to the program.<br></small><br>
  By default, a term beginning with a capital letter is considered
  as non-terminal (thus bound to a definition) and a term beginning
  with a non-capital letter as terminal (a simple word). If you
  need then to specify a capital word you must quote it in order to
  get the program not to mistake it for a non-terminal symbol:<br>
  <br>
  <b><samp>EXAMPLE</samp></b><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> a <font color="#996633">Pet</font> called
  "Pet" <font color="#CC0000">;</font><br>
  <br>
  <font color="#996633">Pet</font> <font color="#CC0000">::=</font>
  cat <font color="#CC0000">|</font> pig <font color=
  "#CC0000">|</font> dog <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <b><samp>PRODUCES<br></samp></b> <code><br>
  a cat called Pet<br>
  a pig called Pet<br>
  a dog called Pet</code><br>
  <br>
  <br>
  Keep in mind that many characters (punctuation marks,
  parentheses, etc), including those interpret as keywords by the
  program, must be quoted to be output (see section <a href=
  "#4.1.3_Regole_lessicali">4.1.3</a> for complete lexical
  rules).<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> "(" <font color="#CC0000">(</font>apple
  <font color="#CC0000">|</font> orange<font color=
  "#CC0000">)</font> ")" <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <samp><b>PRODUCES<br></b></samp> <code><br>
  ( apple )<br>
  ( orange )</code><br>
  <br>
  <br>
  <br>
  <h3><a name="1.0.1_Sottoproduzioni" id=
  "1.0.1_Sottoproduzioni"></a> 1.0.1 Subproductions<br></h3>After
  the keyword <font color="#CC0000"><code>::=</code></font> in a
  definition, a subproduction of any form can be specified between
  round brackets:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> an <font color=
  "#CC0000">(</font></code><code>apple</code> <code><font color=
  "#CC0000">|</font> orange</code><code><font color=
  "#CC0000">)</font> is on the <font color=
  "#CC0000">(</font></code><code>table</code> <code><font color=
  "#CC0000">|</font></code> <code>desk</code><code><font color=
  "#CC0000">)</font> <font color="#CC0000">;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>an apple is on the table<br>
  an orange is on the table<br>
  an apple is on the desk<br>
  an orange is on the desk<br></code><br>
  <br>
  Subproductions are generated as standalone blocks, that is as
  they were bound to a non-terminal symbol.<br>
  <br>
  <h3><a name="1.0.2_Sottoproduzioni_opzionali" id=
  "1.0.2_Sottoproduzioni_opzionali"></a> 1.0.2 Optional
  subproductions<br></h3>A subproduction specified between square
  brakets is considered as optional and is generated 1 every 2
  times, i.e. 50% probability:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> an <font color="#CC0000">(</font>apple
  <font color="#CC0000">|</font> orange<font color=
  "#CC0000">)</font> is on the <font color="#CC0000">(</font>table
  <font color="#CC0000">|</font> desk<font color="#CC0000">)</font>
  <font color="#CC0000">[</font>in the <font color=
  "#CC0000">(</font>living <font color="#CC0000">|</font>
  dining<font color="#CC0000">)</font> room<font color="#CC0000">]
  ;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>an apple is on the table<br>
  an apple is on the table in the living room<br>
  an apple is on the table in the dining room<br>
  an orange is on the table<br>
  an orange is on the table in the living room</code><code><br>
  <br></code> ecc.<br>
  <br>
  <br>
  Optional subproductions, apart from being generated once every
  two times, behave as normal subproductions.<br>
  <br>
  <br>
  <h3><a name="1.0.3_Commenti" id="1.0.3_Commenti"></a> 1.0.3
  Comments<br></h3>You can write any kind of text within a pair of
  <font color="#CC0000"><code>(*</code></font> and <font color=
  "#CC0000"><code>*)</code></font> keywords. Such text will be
  completely ignored by <i>PolyGen.</i><br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> apple <font color="#CC0000">|</font> rainge
  <font color="#666666">(* | banana *)</font> <font color=
  "#CC0000">|</font> mango <font color="#CC0000">;</font><br>
  <font color="#666666">(* this is comment too *)</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>apple<br>
  orange<br>
  mango<br>
  <br>
  <br>
  <br>
  <br></code>
  <h2><a name="2.0_Caratteristiche_avanzate" id=
  "2.0_Caratteristiche_avanzate"></a>2.0 Advanced
  features<br></h2><i>PolyGen</i> provides a set of keywords that
  raises the language expressivity beyond <i>BNF.</i><br>
  <br>
  <br>
  <h3><a name="2.0.1_Concatenazione" id=
  "2.0.1_Concatenazione"></a>2.0.1 Concatenation<br></h3>The
  <b>cap</b> <font color="#CC0000"><code>^</code></font> can be
  either prefixed or suffixed to as well as infixed in any point
  within a production in order to make the program not insert a
  white space character in the output string:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> "(" <font color="#CC0000">^ (</font>apple
  <font color="#CC0000">|</font> orange<font color="#CC0000">)
  ^</font> ")" <font color="#CC0000">;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>(apple)<br>
  (orange)<br>
  <br></code><br>
  Concatenation, as a feature, is particularly useful every time
  you wish to generate words by assembling syllabes or letters
  coming from different productions:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> "I" <font color="#996633">Verb <font color=
  "#CC0000">^</font></font> e <font color="#996633">Verb
  <font color="#CC0000">^</font></font> <font color=
  "#996633">ing</font> <font color="#CC0000">;</font><br>
  <br>
  <font color="#996633">Verb</font> <font color=
  "#CC0000">::=</font> lov <font color="#CC0000">|</font> hat
  <font color="#CC0000">;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>I love hating<br>
  I love loving<br>
  I hate hating<br>
  I hate loving</code><code><br>
  <br></code><br>
  Keep in mind that specifying many caps is perfectly equal to
  specifying one only.<br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.2_Epsilon" id="2.0.2_Epsilon"></a> 2.0.2
  Epsilon<br></h3>The <b>underscore</b> keyword <font color=
  "#CC0000"><code>_</code></font> stands for the empty production,
  formally called <i>epsilon</i>.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> ball <font color="#CC0000">| _ ;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>ball<br>
  <font color="#CC0000">_</font><br></code><br>
  <br>
  Notice that an epsilon-production is neither the underscore
  character itself nor the white space, rather it stands for no
  output at all - the empty string, if you prefer. The former
  example is perfectly equivalent to the following:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color=
  "#CC0000">[</font>palla<font color="#CC0000">] ;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>palla<br>
  <font color="#CC0000">_</font><br></code><br>
  <br>
  That is a grammar generating either <code>a</code> or nothing as
  output.<br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.3_Controllo_della_probabilità_di_una" id=
  "2.0.3_Controllo_della_probabilità_di_una"></a> 2.0.3 Controlling
  the probability of a production<br></h3>The <b>plus</b> keyword
  <font color="#CC0000"><code>+</code></font> , when prefixed to a
  (sub)production (however nested), raises the probability for it
  to be generated, in respect to the others of that very series;
  simmetrically, the <b>minus</b> keyword&nbsp;<font color=
  "#CC0000"><code>-</code></font> lowers it down. Any number
  of&nbsp;<font color="#CC0000"><code>+</code></font> and
  <font color="#CC0000"><code>-</code></font> keywords may be
  specified:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> the cat is eating <font color=
  "#CC0000">(+</font> an apple <font color="#CC0000">|-</font> an
  orange <font color="#CC0000">|</font> some meat <font color=
  "#CC0000">|--</font> a lemon<font color="#CC0000">)
  ;</font><br></code><br>
  <br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>the cat is eating an apple<br>
  the cat is eating an orange<br>
  the cat is eating some meat<br>
  the cat is eating a lemon</code> <code><br>
  <br>
  <br></code><br>
  The set of sentences that can be produced is as expected; indeed,
  the definition for the non-terminal symbol <code><font color=
  "#996633">S</font></code> is internally interpretet as
  follows:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> the cat is eating <font color=
  "#CC0000">(</font> an apple <font color="#CC0000">|</font> an
  apple <font color="#CC0000">|</font> an apple <font color=
  "#CC0000">|</font> an apple<br>
  <font color="#CC0000">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font> an orange
  <font color="#CC0000">|</font> an orange<br>
  <font color="#CC0000">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font> some meat
  <font color="#CC0000">|</font> some meat <font color=
  "#CC0000">|</font> some meat<br>
  <font color="#CC0000">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font> a
  lemon<font color="#CC0000">) ;</font><br>
  <br></code><br>
  as requested, proportion of probabilty raising and lowering
  holds: the probability for&nbsp;<code>an apple</code> to be
  generated is higher than&nbsp;<code>an orange</code>, which is
  higher that&nbsp;<code>some meat</code>, on its turn higher
  than&nbsp;<code>a lemon</code>.<br>
  <br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.4_Unfolding" id="2.0.4_Unfolding"></a> 2.0.4
  Unfolding</h3><i>PolyGen</i> provides a powerful unfolding system
  which, in general, allows to take a series of productions
  (otherwise folded either by a subproduction or a non-terminal
  symbol) to the level of the current sequence.<br>
  Roughly, you may look at this operation as at the
  <i>flattening</i> of a portion of grammar that is performed
  before the generation and that may thus affect it just as far as
  the probability are concerned, since the transformation does not
  alter the source grammar semantics - as the traslation rules in
  section <a href="#4.1.5_Regole_di_traduzione">4.1.5</a>
  confirm.<br>
  <br>
  Not every atom though supports unfolding, rather only those which
  such operation makes sense for: refer to section <a href=
  "#4.1.1_Sintassi_concreta">4.1.1</a> for a syntactical
  formalization of such subset.<br>
  <br>
  <h4><a name="2.0.4.1_Di_simboli_non_terminali" id=
  "2.0.4.1_Di_simboli_non_terminali"></a> 2.0.4.1 Non-terminal
  symbols</h4>Consider the following scenario:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> ugly cat <font color="#CC0000">|</font> nice
  <font color="#996633">Animal</font> <font color=
  "#CC0000">;</font><br>
  <br>
  <font color="#996633">Animal</font> <font color=
  "#CC0000">::=</font> dog <font color="#CC0000">|</font> bull
  <font color="#CC0000">|</font> pig <font color=
  "#CC0000">;</font><br>
  <br>
  <br></code> <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>ugly cat<br>
  nice dog<br>
  nice bull<br>
  nice pig<br>
  <br></code><br>
  Produced output deserves no surprises, still the chance for
  <code>ugly cat</code> to be generated is 1 every 2 times, but it
  is not the same for <code>nice dog</code>, <code>nice bull</code>
  and <code>nice pig</code>, even though a user may find it
  reasonable for all them to be generated with the same
  probability.<br>
  The problem is due to productions <code>ugly cat</code> and
  <code>nice <font color="#996633">Animal</font></code> equally
  sharing the unit of prabability of <code><font color=
  "#996633">S</font></code>: thus the chances for <code>ugly
  cat</code> to be generated is equal to the chances
  for&nbsp;<code>nice <font color="#996633">Animal</font></code>,
  i.e. one among&nbsp;<code>nice dog</code>, <code>nice bull</code>
  and <code>nice pig</code>. In the example above the probability
  distribution appears as follows:<br>
  <br>
  <table border="1" width="30%" cellpadding="2" cellspacing="2"
  bgcolor="#CCCCCC">
    <tbody>
      <tr>
        <td><code>ugly cat</code><br></td>
        <td>1/2</td>
      </tr>
      <tr>
        <td><code>nice dog</code><br></td>
        <td>1/2 * 1/3 = 1/6</td>
      </tr>
      <tr>
        <td><code>nice bull</code><br></td>
        <td>1/2 * 1/3 = 1/6</td>
      </tr>
      <tr>
        <td><code>nice pig</code><br></td>
        <td>1/2 * 1/3 = 1/6</td>
      </tr>
    </tbody>
  </table><br>
  <br>
  As a proof, 1/2 + 1/6 + 1/6 + 1/6 = 1.<br>
  <br>
  In order to equally redistribute prababilities of subproductions,
  the user should write <code><font color="#996633">S</font></code>
  this way:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> ugly cat <font color="#CC0000">|</font> nice
  dog <font color="#CC0000">|</font> nice bull <font color=
  "#CC0000">|</font> nice pig <font color=
  "#CC0000">;</font></code><br>
  <br>
  though loosing the original architecture, which used to fold all
  animals within a non-terminal symbol, and moreover dramatically
  increasing the amount of editing duties.<br>
  In order to solve this problem, itself an instance of the
  dishomogeneity of probability distribution problem in case of
  subproductions, the language offers an operator for
  <b>unfolding</b> non-terminal symbols:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> ugly cat <font color="#CC0000">|</font>
  nice</code> <code><font color=
  "#CC0000">&gt;</font></code><code><font color=
  "#996633">Animal</font> <font color="#CC0000">;</font><br>
  <br>
  <font color="#996633">Animal</font> <font color=
  "#CC0000">::=</font> dog <font color="#CC0000">|</font> bull
  <font color="#CC0000">|</font> pig <font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  Prefixing the <font color="#CC0000"><code>&gt;</code></font>
  keyword to a non-terminal symbol, during the preprocessing phase
  the program performs the translation above, changing the
  probability distribution as follows:<br>
  <br>
  <table border="1" width="30%" cellpadding="2" cellspacing="2"
  bgcolor="#CCCCCC">
    <tbody>
      <tr>
        <td><code>ugly cat</code><br></td>
        <td>1/4</td>
      </tr>
      <tr>
        <td><code>nice dog</code><br></td>
        <td>1/4</td>
      </tr>
      <tr>
        <td><code>nice bull</code><br></td>
        <td>1/4</td>
      </tr>
      <tr>
        <td><code>nice pig</code><br></td>
        <td>1/4</td>
      </tr>
    </tbody>
  </table><br>
  <br>
  <br>
  <h4><a name="2.0.4.2_Di_sottoproduzioni" id=
  "2.0.4.2_Di_sottoproduzioni"></a> 2.0.4.2
  Subproductions<br></h4>It is not uncommon to use subproductions
  in order to decrease grammar verbosity, e.g. by collecting a set
  of phrasal verbs according to the supported preposition.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">(</font>walk</code>
  <code><font color="#CC0000">|</font></code>
  <code>pass<font color="#CC0000">)</font> through<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;look at<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;</code><code><font color=
  "#CC0000">(</font></code><code>go&nbsp;</code><code><font color=
  "#CC0000">|</font></code>
  <code>come&nbsp;</code><code><font color=
  "#CC0000">|</font></code>
  <code>move&nbsp;</code><code><font color=
  "#CC0000">|</font></code>
  <code>link&nbsp;</code><code><font color=
  "#CC0000">|</font></code> <code>run</code><code><font color=
  "#CC0000">)</font></code> <code>to</code> <code><font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  Grammar architecture and scalability increase, on one side,
  while, on the other side, output quality lowers down, since 1
  every 3 times <code>look at</code> will be generated for the same
  reason discussed in section <a href=
  "#2.0.4.1_Di_simboli_non_terminali">2.0.4.1</a>. In order to take
  output etherogeneity to the desired level, that is where each
  single verb may be produced with the same probability, the user
  should avoid round bracket usage at all, so that there would be
  no more 3 macro-productions, and should suffix the proper
  preposition to each verb.<br>
  For this very purpose, any subproduction may be <b>unfolded</b>
  analogously to what stated in section <a href=
  "#2.0.4.1_Di_simboli_non_terminali">2.0.4.1</a> regarding
  non-terminal symbols. The operator <font color=
  "#CC0000"><code>&gt;</code></font> makes the program delegate to
  the preprocessor the unfolding of the following subproduction,
  allowing the user to keep the original source architecture
  unchanged.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color=
  "#CC0000">&gt;(</font>walk</code> <code><font color=
  "#CC0000">|</font></code> <code>pass<font color=
  "#CC0000">)</font> through<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;look at<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;</code><code><font color=
  "#CC0000">&gt;(</font></code><code>go&nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>come&nbsp;</code><code><font color=
  "#CC0000">|</font></code>
  <code>move&nbsp;</code><code><font color=
  "#CC0000">|</font></code>
  <code>link&nbsp;</code><code><font color=
  "#CC0000">|</font></code> <code>run</code><code><font color=
  "#CC0000">)</font></code> <code>to</code> <code><font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  is translated into:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> walk through</code> <code><font color=
  "#CC0000">|</font></code><code>pass through<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;look at<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;</code><code>go to</code> <code><font color=
  "#CC0000">|</font></code> <code>come to</code> <code><font color=
  "#CC0000">|</font></code> <code>move to</code> <code><font color=
  "#CC0000">|</font></code> <code>link to</code> <code><font color=
  "#CC0000">|</font></code> <code>run</code> <code>to</code>
  <code><font color="#CC0000">;</font></code><br>
  <br>
  <br>
  that is what one would expect: a flat series of productions.<br>
  <br>
  A more complex example could be:<br>
  <br>
  <code><font color="#996633">Digit</font> <font color=
  "#CC0000">::=</font> <font color="#3333FF">z:</font> 0
  <font color="#CC0000">|</font> <font color="#3333FF">nz:</font>
  <font color="#CC0000">&gt;(</font></code><code>1 <font color=
  "#CC0000">|</font> 2 <font color="#CC0000">|</font> 3
  <font color="#CC0000">|</font> 4 <font color="#CC0000">|</font> 5
  <font color="#CC0000">|</font> 6 <font color="#CC0000">|</font> 7
  <font color="#CC0000">|</font> 8 <font color="#CC0000">|</font>
  9<font color="#CC0000">) ;</font></code><br>
  <br>
  is translated into:<br>
  <br>
  <code><font color="#996633">Digit</font> <font color=
  "#CC0000">::=</font> <font color="#3333FF">z:</font> 0
  <font color="#CC0000">|</font> <font color=
  "#3333FF">nz:</font></code> <code>1 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>2 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>3 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>4 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>5 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>6<br>
  &nbsp; &nbsp; &nbsp; &nbsp;<font color=
  "#CC0000">|&nbsp;</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>7 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>8 <font color=
  "#CC0000">|</font></code> <code><font color=
  "#3333FF">nz:</font></code> <code>9 <font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  <h4><a name="2.0.4.3_Di_sottoproduzioni_opzionali" id=
  "2.0.4.3_Di_sottoproduzioni_opzionali"></a> 2.0.4.3 Optional
  subproductions</h4>A subproduction in square brackets (see
  section <a href="#1.0.2_Sottoproduzioni_opzionali">1.0.2</a>) is
  equal to a subproduction in round brackets that produces either
  the original content or <b>epsilon</b> (see the example in
  section <a href=
  "#2.1.3_Controllo_della_probabilt%E0_di_una">2.1.3</a>).<br>
  Thus, <b>unfolding</b> an optional subproduction is perfectly
  legal and the result is analogous to what said in section
  <a href="#2.0.4.2_Di_sottoproduzioni">2.0.4.2</a>.<br>
  <br>
  <br>
  <h4><a name="2.0.4.4_Di_sottoproduzioni_permutabili" id=
  "2.0.4.4_Di_sottoproduzioni_permutabili"></a> 2.0.4.4 Permutable
  subproductions</h4>As the translation rules in section <a href=
  "#4.1.5_Regole_di_traduzione">4.1.5</a> reveal, the unfolding is
  performed by the preprocessor after all the permutations (see
  section <a href="#2.0.7_Permutazioni">2.0.7</a>) occured: a
  permutable subproduction bound to a <font color=
  "#CC0000"><code>&gt;</code></font> operator is therefore first
  permutated, while the <b>unfolding</b> holds and is then
  performed at the new position within the sequence.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">&gt;{</font>the
  <font color="#CC0000">&gt;(</font>dog <font color=
  "#CC0000">|</font> cat<font color="#CC0000">)}</font> and</code>
  <code><font color="#CC0000">{</font></code><code>a</code>
  <code><font color="#CC0000">(</font></code><code>fish</code>
  <code><font color="#CC0000">|</font></code>
  <code>bull</code><code><font color="#CC0000">)}</font></code>
  <code><font color="#CC0000">;</font></code><br>
  <br>
  <br>
  Pay attention to how the two unfoldings, the former inside the
  curly brackets and the latter outside, behave: the translation is
  as follows:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> the dog and a</code> <code><font color=
  "#CC0000">(</font></code><code>fish</code> <code><font color=
  "#CC0000">|</font></code> <code>bull</code><code><font color=
  "#CC0000">)</font></code><br>
  <code>&nbsp; &nbsp;</code><code><font color=
  "#CC0000">|</font></code> <code>&nbsp;the cat and
  a&nbsp;</code><code><font color=
  "#CC0000">(</font></code><code>fish</code> <code><font color=
  "#CC0000">|</font></code> <code>bull</code><code><font color=
  "#CC0000">)</font></code><br>
  <code>&nbsp; &nbsp;</code><code><font color=
  "#CC0000">|</font></code>
  <code>&nbsp;</code>a&nbsp;<code><font color=
  "#CC0000">(</font></code><code>fish</code> <code><font color=
  "#CC0000">|</font></code> <code>bull</code><code><font color=
  "#CC0000">)</font></code> <code>and the dog<br>
  &nbsp; &nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>&nbsp;</code>a&nbsp;<code><font color=
  "#CC0000">(</font></code><code>fish</code> <code><font color=
  "#CC0000">|</font></code> <code>bull</code><code><font color=
  "#CC0000">)</font></code> <code>and the cat</code>
  <code><font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <h4><a name="2.0.4.5_Di_sottoproduzioni_soggette" id=
  "2.0.4.5_Di_sottoproduzioni_soggette"></a> 2.0.4.5 Deeply
  unfolded subproductions</h4>As stated in section <a href=
  "#2.0.8_Unfolding_in_profondit%E0">2.0.8</a>, deep unfolding
  leads to a subproduction where everything has been flattened
  within.<br>
  Though, one may sometimes wish to perform a further
  <b>unfolding</b>: of that very subproduction.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font>&nbsp;</code> <code><font color=
  "#CC0000">&gt; &gt;&gt;</font> the</code> <code><font color=
  "#CC0000">(</font></code><code>dog</code> <code><font color=
  "#CC0000">|</font></code> <code>cat</code><code><font color=
  "#CC0000">)</font></code> <code><font color="#CC0000">|</font> a
  <font color="#CC0000">(</font>fish <font color="#CC0000">|</font>
  bull<font color="#CC0000">) &lt;&lt; |</font> an alligator
  <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  that is translated into:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> the dog</code> <code><font color=
  "#CC0000">|</font></code> <code>the cat</code> <code><font color=
  "#CC0000">|</font></code> <code>a fish</code> <code><font color=
  "#CC0000">|</font></code> <code>a bull</code> <code><font color=
  "#CC0000">|</font></code> <code>an alligator</code>
  <code><font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.5_Attributi" id="2.0.5_Attributi"></a> 2.0.5
  Attributes<br></h3>
  <h4><a name="2.0.5.1_Etichette_e_selezione" id=
  "2.0.5.1_Etichette_e_selezione"></a> 2.0.5.1 Labels and
  selection<br></h4>Any (sub)production, however nested, can be
  bound to a label and it is eventually possible to limit
  generation to a subset of a series of productions by using the
  <b>dot</b> operator.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color=
  "#996633">Verb</font><font color="#339999">.inf</font>
  <font color="#CC0000">|</font> <font color=
  "#996633">Verb</font><font color="#339999">.ing</font>
  <font color="#CC0000">;</font><br>
  <br>
  <font color="#996633">Verb</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">(</font><font color=
  "#3333FF">inf:</font> to<font color="#CC0000">) (</font>eat
  <font color="#CC0000">|</font> drink <font color=
  "#CC0000">|</font> jump<font color="#CC0000">)
  (</font><font color="#3333FF">ing:</font> <font color=
  "#CC0000">^</font>ing<font color="#CC0000">) ;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>to eat<br>
  to drink<br>
  to jump<br>
  eating<br>
  drinking<br>
  jumping<br></code> <code><br></code><br>
  Selection simply deletes all (sub)productions bound to a label
  other than the one selected. More precisely, a selection
  propagates the label specified on the right hand of the dot
  operator for the whole generation of what stands on the left of
  it; during the generation will be considered as valid both those
  (sub)productions that are bound to no label and those bound to a
  label that has been selected.<br>
  Notice therefore that you're allowed to use selection many times
  in order to enrich the list of selected labels: such a technique
  may be useful for propagating some attributes that are wanted to
  affect generation.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">(</font><font color=
  "#996633">Conjug</font><font color="#339999">.S</font>
  <font color="#CC0000">|</font> <font color=
  "#996633">Conjug</font><font color=
  "#339999">.P</font><font color="#CC0000">)</font><font color=
  "#339999">.sp</font> <font color=
  "#CC0000">|</font>&nbsp;</code><code><font color=
  "#CC0000">(</font><font color="#996633">Conjug</font><font color=
  "#339999">.S</font> <font color="#CC0000">|</font> <font color=
  "#996633">Conjug</font><font color=
  "#339999">.P</font><font color="#CC0000">)</font><font color=
  "#339999">.pp</font></code> <code><font color=
  "#CC0000">;</font><br>
  <br>
  <font color="#996633">Conjug</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">(</font><font color=
  "#996633">Pronoun</font> <font color=
  "#996633">Verb</font><font color="#CC0000">)</font><font color=
  "#339999">.1</font> <font color=
  "#CC0000">|</font>&nbsp;</code><code><font color=
  "#CC0000">(</font><font color="#996633">Pronoun</font>
  <font color="#996633">Verb</font><font color=
  "#CC0000">)</font><font color="#339999">.2</font> <font color=
  "#CC0000">|</font></code> <code><font color=
  "#CC0000">(</font><font color="#996633">Pronoun</font>
  <font color="#996633">Verb</font><font color=
  "#CC0000">)</font><font color="#339999">.3</font></code>
  <code><font color="#CC0000">;</font><br>
  <br>
  <font color="#996633">Pronoun</font> <font color=
  "#CC0000">::=</font> <font color="#3333FF">S:</font> <font color=
  "#CC0000">(</font><font color="#3333FF">1:</font> "I"
  <font color="#CC0000">|</font> <font color="#3333FF">2:</font>
  you <font color="#CC0000">|</font> <font color=
  "#3333FF">3:</font> <font color="#CC0000">(</font>he <font color=
  "#CC0000">|</font> she <font color="#CC0000">|</font>
  it<font color="#CC0000">)</font><font color=
  "#CC0000">)</font><br>
  <font color="#CC0000">&nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;|&nbsp;</font> <font color=
  "#3333FF">P:</font>&nbsp;</code><code><font color=
  "#CC0000">(</font><font color="#3333FF">1:</font> we <font color=
  "#CC0000">|</font> <font color="#3333FF">2:</font> you
  <font color="#CC0000">|</font> <font color="#3333FF">3:</font>
  they<font color="#CC0000">)</font></code> <code><font color=
  "#CC0000">;</font><br>
  <br>
  <font color="#996633">Verb</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">(</font><font color=
  "#3333FF">pp:</font> <font color="#996633">Be</font><font color=
  "#CC0000">)</font> <font color="#CC0000">(</font>eat <font color=
  "#CC0000">|</font> drink<font color="#CC0000">)
  (</font><font color="#3333FF">sp:</font></code>
  <code><font color="#CC0000">(</font><font color=
  "#3333FF">S:</font> (<font color="#3333FF">3:</font> <font color=
  "#CC0000">^</font>s<font color="#CC0000">))</font> <font color=
  "#CC0000">|</font> <font color="#3333FF">pp:</font> <font color=
  "#CC0000">^</font>ing<font color="#CC0000">)
  ;</font></code><code><br>
  <br>
  <font color="#996633">Be</font> <font color="#CC0000">::=</font>
  <font color="#3333FF">S:</font> <font color=
  "#CC0000">(</font><font color="#3333FF">1:</font> am <font color=
  "#CC0000">|</font> <font color="#3333FF">2:</font> are
  <font color="#CC0000">|</font> <font color="#3333FF">3:</font>
  is<font color="#CC0000">)</font> <font color="#CC0000">|</font>
  <font color="#3333FF">P:</font> are <font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>I eat<br>
  you eat<br>
  he eats<br>
  she eats<br>
  it eats<br>
  we eat<br>
  they eat<br>
  I am eating<br>
  you are eating<br>
  he is eating<br>
  we are eating</code><code><br>
  <br></code> etc.<br>
  <br>
  <br>
  In the example above, assuming labels <font color=
  "#3333FF"><code>1,2,3,S</code></font> and <font color=
  "#3333FF"><code>P</code></font> respectively identify syntactical
  forms for the first, second and third persons, singular and
  plural, we managed to correctly conjugate both simple present and
  present progressive tenses according to a pronoun.<br>
  Notice that whenever you decide to extend the set of verbs,
  you'll just need to add more radixes in the proper subproduction
  of <font color="#996633"><code>Verb</code></font>.<br>
  <br>
  <br>
  <h4><a name="2.0.5.2_Selezione_multipla" id=
  "2.0.5.2_Selezione_multipla"></a> 2.0.5.2 Multiple
  selection<br></h4>Reconsider the example in seciton <a href=
  "#2.0.5.1_Etichette_e_selezione">2.0.5.1</a>: the definition of
  the non-terminal <code><font color="#996633">S</font></code>
  simply activates all combos of label pairs <code><font color=
  "#3333FF">S,P</font></code> and <code><font color=
  "#3333FF">sp,pp</font></code> for the production of <font color=
  "#996633"><code>Conjug</code></font>. In order to avoid such
  frequent uncomfortable solutions you're allowed to specifiy, on
  the right of the <b>dot</b> operator, a set of labels in round
  brackets interleaved by the <b>pipe</b> keyword.<br>
  Modifying the example above:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color=
  "#996633">Conjug</font><font color=
  "#339999">.(S</font><font color="#339999">|P)</font><font color=
  "#339999">.(sp|pp)</font> <font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  Analogously to what stated in section <a href=
  "#2.0.3_Controllo_della_probabilit%E0_di_una">2.0.3</a> for
  grammar productions, it is possible to specify probablity
  modifiers for labels too, by means of the <code><font color=
  "#CC0000">+</font></code> and <code><font color=
  "#CC0000">-</font></code> keywords.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#996633">Ogg</font><font color=
  "#339999">.(+S</font><font color=
  "#339999">|--P)</font><font color="#339999">.(sp|-pp)</font>
  <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  That is internally treated as:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">(</font><font color=
  "#996633">Conjug</font><font color="#339999">.S</font>
  <font color="#CC0000">|</font>&nbsp;</code><code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font></code><code>&nbsp;</code><code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font></code><code>&nbsp;</code><font color=
  "#996633">Conjug</font><code><font color="#339999">.S</font>
  <font color="#CC0000">|</font></code> <code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.P</font><font color="#CC0000">)</font><font color=
  "#339999">.sp<br></font></code> <code><font color=
  "#CC0000">&nbsp; &nbsp;</font></code><code><font color=
  "#CC0000">|</font></code><code><font color=
  "#CC0000">&nbsp;&nbsp;<code><font color=
  "#CC0000">(</font><font color="#996633">Conjug</font><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font>&nbsp;</code><code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font></code><code>&nbsp;</code><code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font></code><code>&nbsp;</code><font color=
  "#996633">Conjug</font></font></code><code><font color=
  "#339999">.S</font> <font color="#CC0000">|</font></code>
  <code><font color=
  "#996633">Conjug</font></code><code><font color="#339999">.P</font><font color="#CC0000">)</font><font color="#339999">.sp</font></code><br>

  <code><font color="#CC0000">&nbsp;
  &nbsp;|</font></code><code><font color=
  "#CC0000">&nbsp;&nbsp;<code><font color=
  "#CC0000">(</font><font color="#996633">Conjug</font><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font>&nbsp;</code><code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font></code><code>&nbsp;</code><code><font color=
  "#996633">Conjug</font></code><code><font color=
  "#339999">.S</font> <font color=
  "#CC0000">|</font></code><code>&nbsp;</code><font color=
  "#996633">Conjug</font></font></code><code><font color=
  "#339999">.S</font> <font color="#CC0000">|</font></code>
  <code><font color=
  "#996633">Conjug</font></code><code><font color="#339999">.P</font><font color="#CC0000">)</font><font color="#339999">.pp</font></code>
  <code><font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.6_Maiuscole" id="2.0.6_Maiuscole"></a> 2.0.6
  Capitalization</h3>It is often needed, mainly for style purposes,
  to respect capitalization rules, for instance after a point
  mark.<br>
  Nevertheless, a complex grammar architecture, providing recursive
  productions generating subclauses, may make such operation
  impossible, unless the user rewrites part of the source.<br>
  In order to solve this problem, the language provides the
  <b>backslash</b> keyword <font color=
  "#CC0000"><code>\</code></font>, which makes the program perform
  the capitalization of the very following terminal symbol, i.e.
  switching its first letter to uppercase.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#CC0000">\</font> smith
  <font color="#CC0000">(</font>is <font color="#CC0000">|</font>
  "." <font color="#CC0000">\)</font> <font color=
  "#996633">Eulogy</font></code> <code><font color=
  "#CC0000">^</font> "."</code> <code><font color=
  "#CC0000">;</font></code><br>
  <code><br>
  <font color="#996633">Eulogy</font></code> <code><font color=
  "#CC0000">::=</font></code> <code>rather a smart man<br>
  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</code><code><font color=
  "#CC0000">|</font></code> <code>&nbsp;really a gentleman
  <font color="#CC0000">;</font></code><br>
  <br>
  <samp><b>PRODUCE</b></samp><br>
  <br>
  <code>Smith is rather a smart man.<br></code> <code>Smith. Rather
  a smart man.</code><br>
  <code>Smith is really a gentleman.<br></code> <code>Smith. Really
  a gentleman.</code><br>
  <br>
  <br>
  Keep in mind that capitalization is active until the following
  terminal symbol resulting from the generation, therefore every
  other atom (epsilon, concatenation or the capitalization operator
  itself) found in the middle simply acts as usual.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> a <font color="#CC0000">\ ^ \ _</font>
  b</code><br>
  <code><br>
  <samp><b>PRODUCES</b></samp></code><br>
  <br>
  aB<br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.7_Permutazioni" id="2.0.7_Permutazioni"></a>
  2.0.7 Permutation</h3>Many spoken languages allow to change the
  order of some words (or groups of words) in a sentence holding
  the original meaning; analogously, at a macroscopic level, it
  sometimes makes sense to exchange the sentences of a phrase.<br>
  In order to avoid the user to rewrite the same sequence over and
  over exchanging atom positions, specifying some subprodutions
  within <b>curly brackets</b> <code><font color=
  "#CC0000">{</font></code> and <code><font color=
  "#CC0000">}</font></code>, the program automatically performs all
  the permutations among them.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> whether</code> <code><font color=
  "#CC0000">{</font></code><code>is</code><code><font color=
  "#CC0000">}</font></code><code>&nbsp;</code><code><font color=
  "#CC0000">{</font></code><code>therefore</code><code><font color=
  "#CC0000">}</font></code><code>&nbsp;</code><code><font color=
  "#CC0000">{</font></code><code>he</code><code><font color=
  "#CC0000">}</font></code> <code><font color=
  "#CC0000">;</font></code><br>
  <code><br>
  <samp><b>PRODUCES</b></samp></code><br>
  <br>
  whether is therefore he<br>
  whether is he therefore<br>
  whether therefore is he<br>
  whether therefore he is<br>
  whether he therefore is<br>
  whether he is therefore<br>
  <br>
  <br>
  Keep in mind that the permutability of a subproduction only holds
  within the sequence containing it: no permutation occurs if
  permutable subproductions are specified in different subsequences
  (or subprodutions - permutable or not). See the difference in the
  two example that follow:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font></code> <code><font color=
  "#CC0000">{</font></code><code>in 10
  minutes</code><code><font color=
  "#CC0000">}</font></code><code><font color=
  "#CC0000">^</font>,</code> <code><font color=
  "#CC0000">{</font></code><code>at 3
  o'clock</code><code><font color="#CC0000">}^</font>,</code>
  <code><font color="#CC0000">{</font>"I" <font color=
  "#CC0000">{</font>will depart<font color="#CC0000">}
  {</font></code><code>alone</code><code><font color=
  "#CC0000">}</font></code><code><font color=
  "#CC0000">}</font></code> <code><font color=
  "#CC0000">;</font></code><br>
  <code><br>
  <samp><b>PRODUCES</b></samp></code><br>
  <br>
  in 10 minutes, at 3 o'clock, I will depart alone<br>
  at 3 o'clock, in 10 minutes,&nbsp;I will depart alone<br>
  in 10 minutes, I will depart alone, at 3 o'clock<br>
  at 3 o'clock, I will depart alone, in 10 minutes<br>
  I will depart alone, in 10 minutes, at 3 o'clock<br>
  I will depart alone, at 3 o'clock, in 10 minutes<br>
  in 10 minutes, at 3 o'clock, I alone will depart<br>
  at 3 o'clock, in 10 minutes,&nbsp;I alone will depart<br>
  in 10 minutes,&nbsp;I alone will depart, at 3 o'clock<br>
  at 3 o'clock,&nbsp;I alone will depart, in 10 minutes<br>
  I alone will depart, in 10 minutes, at 3 o'clock<br>
  I alone will depart, at 3 o'clock, in 10 minutes<br>
  <br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font></code> <code><font color=
  "#CC0000">{</font></code><code>in 10
  minutes</code><code><font color=
  "#CC0000">}</font></code><code><font color=
  "#CC0000">^</font>,</code> <code><font color=
  "#CC0000">{</font></code><code>at 3
  o'clock</code><code><font color="#CC0000">}^</font>,</code>
  <code><font color="#CC0000">(</font><code>"I"</code> <font color=
  "#CC0000"><code><font color=
  "#CC0000">{</font></code></font><code>will depart<font color=
  "#CC0000">}</font> <font color=
  "#CC0000">{</font></code><code>alone</code><font color=
  "#CC0000"><code><font color=
  "#CC0000">}</font></code></font></code><code><font color=
  "#CC0000">)</font></code> <code><font color=
  "#CC0000">;</font></code><br>
  <code><br>
  <samp><b>PRODUCES</b></samp></code><br>
  <br>
  in 10 minutes, at 3 o'clock,&nbsp;I will depart alone<br>
  at 3 o'clock, in 10 minutes,&nbsp;I will depart alone<br>
  in 10 minutes, at 3 o'clock,&nbsp;I alone will depart<br>
  at 3 o'clock, in 10 minutes, I alone will depart<br>
  <br>
  <br>
  <h3><a name="2.0.8_Unfolding_in_profondità" id=
  "2.0.8_Unfolding_in_profondità"></a> 2.0.8 Deep unfolding</h3>The
  language allows the deep unfolding of a subproduction specified
  in reverse-doubleangle brackets <font color=
  "#CC0000"><code>&gt;&gt;</code></font> and <font color=
  "#CC0000"><code>&lt;&lt;</code></font>: any atom, however nested,
  for which the unfolding operation makes sense (see section
  <a href="#2.0.4_Unfolding">2.0.4</a>) is unfolded. As a result,
  the complete flattening of every subproduction and non-terminal
  symbol is done:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> look at <font color=
  "#CC0000">&gt;&gt;</font></code> <code><code>the</code>
  <font color="#3333FF"><code><font color=
  "#CC0000">(</font></code></font><code>dog</code> <font color=
  "#3333FF"><code><font color="#CC0000">|</font></code>
  <code><font color=
  "#CC0000">(</font></code></font><code>sorian</code> <font color=
  "#3333FF"><code><font color="#CC0000">|</font></code>
  </font><code>persian</code><font color=
  "#3333FF"><code><font color=
  "#CC0000">)&nbsp;</font></code></font><code>cat</code><font color="#3333FF"><code><font color="#CC0000">)</font></code></font></code><br>

  <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;|</font></code>
  <code>a&nbsp;</code><code><font color=
  "#CC0000">(</font></code><code>cow</code> <code><font color=
  "#CC0000">|</font></code> <code>bull</code> <code><font color=
  "#CC0000">|</font></code> <code><font color=
  "#996633">Animal</font></code><code><font color=
  "#CC0000">)</font></code><code><br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=
  "#CC0000">&nbsp; &lt;&lt;</font> <font color=
  "#CC0000">;</font></code><br>
  <code><br>
  <font color="#996633">Animal</font></code> <code><font color=
  "#CC0000">::=</font></code> <code>pig</code> <code><font color=
  "#CC0000">|</font></code> <code><font color=
  "#CC0000">(</font></code><code>weird&nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>ugly</code><code><font color="#CC0000">)</font></code>
  <code>chicken <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  <br>
  The non-terminal <code><font color="#996633">S</font></code> is
  translated into:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> look at</code> <code><font color=
  "#CC0000">(</font></code> <code>the dog<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;
  |</font></code><code>&nbsp;</code><code>the</code>
  <code><code>sorian</code> <code>cat</code></code><br>
  <code><font color="#CC0000">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp; &nbsp;
  |</font></code><code>&nbsp;</code><code>the persian</code><code>
  <code>cat</code></code><br>
  <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color=
  "#CC0000">|</font></code><code>&nbsp;</code><code>a cow<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;
  |</font></code><code>&nbsp;</code><code>a bull<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;
  |</font></code><code>&nbsp;</code><code>a pig</code><br>
  <code><font color="#CC0000">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp; &nbsp;
  |</font></code><code>&nbsp;</code><code>a</code>
  <code><font color=
  "#CC0000">(</font></code><code>weird&nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>ugly</code><code><font color="#CC0000">)</font></code>
  <code>chicken</code><br>
  <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">)</font></code> <code><font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  Deeply unfolded subproductions are therefore translated into a
  subproduction with everything has been recursively flattened in;
  exceptions are subproductions bound to non-terminal symbols. The
  reason of this behaviour is dued to deep unfolding being an
  operation which actually performs a simple unfolding of every
  (sub)atom for which such operation makes sense: thus, while
  non-terminals are unfolded, productions bound to them are left
  untouched. Even though such a policy may seem unjustified at
  first, it rather allows the user to specify any non-terminal
  symbol within a reverse-doubleangle subproduction without
  unintentionally generating either a huge series of unfoldings or
  - even worse - cyclic unfoldings (see section <a href=
  "#3.0.1.3_Unfolding_ricorsivi">3.0.1.3</a>).<br>
  <br>
  <br>
  <br>
  <h3><a name="2.0.9_Folding" id="2.0.9_Folding"></a> 2.0.9
  Folding</h3>Deep unfolding, as described in section <a href=
  "#2.0.8_Unfolding_in_profondit%E0">2.0.8</a>, may sometimes not
  be what one wishes: on one hand, it would realistically be mostly
  used to avoid the explicit specification of a <font color=
  "#CC0000"><code>&gt;</code></font> operator for every
  subproduction or non-terminal symbol within a given
  subproduction; on the other hand, it still is sometimes
  impossible to perform a deep unfolding of every (sub)atom without
  generating (unintentional) errors. The <i>PolyGen</i> grammar
  definition language allows therefore the user to <b>lock</b> the
  unfolding (of an atom for which such operation would make sense)
  by means of the prefix operator <font color=
  "#CC0000"><code>&lt;</code></font>.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> look at <font color=
  "#CC0000">&gt;&gt;</font></code> <code><code>the</code>
  <font color="#3333FF"><code><font color=
  "#CC0000">(</font></code></font><code>dog</code> <font color=
  "#3333FF"><code><font color="#CC0000">|</font></code>
  </font></code><font color=
  "#CC0000"><code>&lt;</code></font><code><font color=
  "#3333FF"><code><font color=
  "#CC0000">(</font></code></font><code>sorian</code> <font color=
  "#3333FF"><code><font color="#CC0000">|</font></code>
  </font><code>persian</code><font color=
  "#3333FF"><code><font color=
  "#CC0000">)&nbsp;</font></code></font><code>cat</code><font color="#3333FF"><code><font color="#CC0000">)</font></code></font></code><br>

  <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;|</font></code>
  <code>a&nbsp;</code><code><font color=
  "#CC0000">(</font></code><code>cow</code> <code><font color=
  "#CC0000">|</font></code> <code>bull</code> <code><font color=
  "#CC0000">|</font></code> <font color=
  "#CC0000"><code>&lt;</code></font><code><font color=
  "#996633">Animal</font></code><code><font color=
  "#CC0000">)</font></code><code><br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color=
  "#CC0000">&nbsp; &lt;&lt;</font> <font color=
  "#CC0000">;</font></code><br>
  <code><br>
  <font color="#996633">Animal</font></code> <code><font color=
  "#CC0000">::=</font></code> <code>pig</code> <code><font color=
  "#CC0000">|</font></code> <code><font color=
  "#CC0000">(</font></code><code>weird&nbsp;</code><code><font color="#CC0000">|</font></code>
  <code>ugly</code><code><font color="#CC0000">)</font></code>
  <code>chicken <font color="#CC0000">;</font></code><br>
  <br>
  <br>
  where the non-terminal <code><font color=
  "#996633">S</font></code> is translated into:<br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> look at</code> <code><font color=
  "#CC0000">(</font></code> <code>the dog<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;
  |</font></code><code>&nbsp;</code><code>the</code>
  <code><font color="#3333FF"><code><font color=
  "#CC0000">(</font></code></font><code>sorian</code> <font color=
  "#3333FF"><code><font color="#CC0000">|</font></code>
  </font><code>persian</code><font color=
  "#3333FF"><code><font color=
  "#CC0000">)</font></code></font></code><code>
  <code>cat</code></code><br>
  <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color=
  "#CC0000">|</font></code><code>&nbsp;</code><code>a cow<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;
  |</font></code><code>&nbsp;</code><code>a bull<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">&nbsp;
  |</font></code><code>&nbsp;</code><code>a&nbsp;</code><code><font color="#996633">Animal</font></code><br>

  <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code>
  <code><font color="#CC0000">)</font></code> <code><font color=
  "#CC0000">;</font></code><br>
  <br>
  Keep in mind that folding an unfolded atom and viceversa are
  syntax errors - see section <a href=
  "#4.1.1_Sintassi_concreta">4.1.1</a>.<br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <h2><a name="2.1_Tecniche_avanzate" id=
  "2.1_Tecniche_avanzate"></a>2.1 Advanced techniques<br></h2>
  <h3><a name="2.1.1_Ricorsione" id="2.1.1_Ricorsione"></a>2.1.1
  Recursion<br></h3>It is perfectly legal for you to specify in a
  production the non-terminal symbol you're defining, in order to
  make <i>PolyGen</i> recur:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#996633">Digit</font>
  <font color="#CC0000">[^</font> <font color=
  "#996633">S</font><font color="#CC0000">] ;</font><br>
  <br>
  <font color="#996633">Digit</font> <font color=
  "#CC0000">::=</font> 0 <font color="#CC0000">|</font> 1
  <font color="#CC0000">|</font> 2 <font color="#CC0000">|</font> 3
  <font color="#CC0000">|</font> 4 <font color="#CC0000">|</font> 5
  <font color="#CC0000">|</font> 6 <font color="#CC0000">|</font> 7
  <font color="#CC0000">|</font> 8 <font color="#CC0000">|</font> 9
  <font color="#CC0000">;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>0<br>
  23<br>
  853211<br>
  000000<br>
  00011122335<br>
  <br></code> etc.<br>
  <br>
  <br>
  i.e. any natural number made up by a random number of digits
  randomly chosen between 0 and 9.<br>
  Keep in mind then that it is up to you providing a non-recursive
  production somewhere in order to let the program stop recurring
  sooner or later, otherwise a cyclic recursion error will be
  generated by the grammar checker (see section <a href=
  "#3.0.1.2_Ricorsioni_cicliche_e">3.0.1.2</a>).<br>
  <br>
  As an exercize, try to define a grammar for generating
  variably-lengthened sentences obtained by recursively linking
  clauses.<br>
  <br>
  <br>
  <br>
  <h3><a name="2.1.2_Ragruppamento" id="2.1.2_Ragruppamento"></a>
  2.1.2 Grouping<br></h3>In order to gain control over the
  probability distribution in even a more flexible way than how
  described in sections&nbsp;<a href=
  "#2.0.3_Controllo_della_probabilit%E0_di_una">2.0.3</a> and
  <a href="#2.0.4_Unfolding">2.0.4</a>, proper usage of round
  brakets should be considered:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S1</font> <font color=
  "#CC0000">::=</font> canarin <font color="#CC0000">|</font> cow
  <font color="#CC0000">|</font> camel <font color=
  "#CC0000">;</font><br>
  <br>
  <font color="#996633">S2</font> <font color="#CC0000">::=</font>
  canarin <font color="#CC0000">|</font> <font color=
  "#CC0000">(</font>cow <font color="#CC0000">|</font>
  camel<font color="#CC0000">) ;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>canarin<br>
  cow<br>
  camel<br>
  <br></code><br>
  Although <code><font color="#996633">S1</font></code> and
  <code><font color="#996633">S2</font></code> outputs are equal,
  the probability distribution for the former is:<br>
  <br>
  <table border="1" width="30%" cellpadding="2" cellspacing="2"
  bgcolor="#CCCCCC">
    <tbody>
      <tr>
        <td><code>cat</code><br></td>
        <td>1/3</td>
      </tr>
      <tr>
        <td><code>cow</code><br></td>
        <td>1/3</td>
      </tr>
      <tr>
        <td><code>camel</code></td>
        <td>1/3</td>
      </tr>
    </tbody>
  </table><br>
  <br>
  while for the latter:<br>
  <br>
  <table border="1" width="30%" cellpadding="2" cellspacing="2"
  bgcolor="#CCCCCC">
    <tbody>
      <tr>
        <td><code>cat</code></td>
        <td>1/2</td>
      </tr>
      <tr>
        <td><code>cow</code></td>
        <td>1/2 * 1/2 = 1/4</td>
      </tr>
      <tr>
        <td><code>camel</code></td>
        <td>1/2 * 1/2 = 1/4</td>
      </tr>
    </tbody>
  </table><br>
  <br>
  All this because the subproduction&nbsp;<code><font color=
  "#CC0000">(</font>cow <font color="#CC0000">|</font>
  camel<font color="#CC0000">)</font></code> is interpreted someway
  as a whole block by the program.<br>
  <br>
  <br>
  <br>
  <h3><a name="2.1.3_Controllo_della_probabiltà_di_una" id=
  "2.1.3_Controllo_della_probabiltà_di_una"></a> 2.1.3 Controlling
  the probability of an optional subproduction</h3>The grammar
  definition language interpreted by <i>PolyGen</i> does not allow
  any control over the probability for an optional subproduction to
  occur. In other words, there is no <b>plus</b>- or
  <b>minus</b>-like operator for subproductions in square
  brackets.<br>
  Nevertheless there exists a simple technique to get this
  result:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> a <font color="#CC0000">(+ _ |</font>
  beautiful<font color="#CC0000">)</font> house <font color=
  "#CC0000">;</font><br>
  <br></code><br>
  <samp><b>PRODUCE</b></samp><br>
  <br>
  <code>a house<br>
  a beautiful house<br>
  <br></code><br>
  Being an optional subproduction equivalent to a non-optional one
  generating either a given output or epsilon (see section <a href=
  "#2.0.2_Epsilon">2.0.2</a>), it is possible to make this
  translation by hand and eventually put plus and minus
  operators.<br>
  In the former example, the probability for nothing to be produced
  is greater than the probability for <code>beautiful.</code><br>
  <br>
  <br>
  <br>
  <h3><a name="2.1.4_Reset_di_una_selezione" id=
  "2.1.4_Reset_di_una_selezione"></a> 2.1.4 Selection
  reset<br></h3>Keep in mind that the selection operator adds the
  specified label to the set of already active ones; this leads to
  the need to someway manually reset such set. For instance, let
  generate natural numbers (included zero) of arbitrary length
  without any non-significative zero:<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#996633">Digit</font>
  <font color="#CC0000">|</font> <font color=
  "#996633">S</font><font color="#339999">.nz</font> <font color=
  "#CC0000">[^</font> <font color="#996633">S</font><font color=
  "#339999">.</font><font color="#CC0000">] ;</font><br>
  <br>
  <font color="#996633">Digit</font> <font color=
  "#CC0000">::=</font> <font color="#3333FF">z:</font> 0
  <font color="#CC0000">|</font> <font color="#3333FF">nz:</font>
  <font color="#CC0000">{</font></code><code>1 <font color=
  "#CC0000">|</font> 2 <font color="#CC0000">|</font> 3
  <font color="#CC0000">|</font> 4 <font color="#CC0000">|</font> 5
  <font color="#CC0000">|</font> 6 <font color="#CC0000">|</font> 7
  <font color="#CC0000">|</font> 8 <font color="#CC0000">|</font>
  9<font color="#CC0000">} ;</font></code><br>
  <code><br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>0<br>
  1<br>
  23<br>
  23081993<br>
  112358<br>
  20020723<br>
  <br></code> ecc.<br>
  <br>
  The dot operator followed by no label resets the set of active
  selections at the time it is encountered during generation; in
  other words, it stops propagation of labels selected that
  far.<br>
  <br>
  <br>
  <br>
  <h2><a name="3.0_Controllo_statico_di_una_grammatica" id=
  "3.0_Controllo_statico_di_una_grammatica"></a> 3.0 Static
  checking of grammars<br></h2><i>PolyGen</i> features a powerful
  algorithm performing a static checking of a source file: it is
  therefore able to verify the correctness of a whole grammar in
  finite time despite its complexity.<br>
  A grammar source succeding the checking phase is guaranteed to
  always generate a valid output - as kind of a soundness.<br>
  Thus, since the checking phase always precedes generation, if the
  program outputs with no error messages, then the grammar is
  entirely correct.<br>
  <br>
  Where specified within the message generated by the program,
  warnings and errors refer to a source text file area between two
  pairs of coordinates showing a line number and a column
  number.<br>
  <br>
  <br>
  <h3><a name="3.0.1_Errori" id="3.0.1_Errori"></a> 3.0.1
  Errors<br></h3>Errors are classified as cases that break the
  grammar correctness definition.<br>
  An error halts the program execution.<br>
  <br>
  <h4><a name="3.0.1.1_Inesistenza_di_simboli_non" id=
  "3.0.1.1_Inesistenza_di_simboli_non"></a> 3.0.1.1 Undefined
  non-terminal symbols<br></h4>Each non-terminal symbol appearing
  in the right-hand of a definition is checked for actually
  existence in order to avoid usage of non-terminal symbols that
  have not been defined.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#996633">A</font> <font color=
  "#CC0000">|</font> <font color="#996633">B</font> <font color=
  "#CC0000">;</font><br>
  <font color="#996633">A</font> <font color="#CC0000">::=</font> a
  <font color="#CC0000">;</font><br>
  <br></code><br>
  Such grammar generates an error message, since <font color=
  "#996633"><code>B</code></font> is not defined.<br>
  <br>
  <br>
  <h4><a name="3.0.1.2_Ricorsioni_cicliche_e" id=
  "3.0.1.2_Ricorsioni_cicliche_e"></a> 3.0.1.2 Cyclic recursions
  and non-termination<br></h4>The checking algorithm is able to
  verify each non-terminal symbol to possibly produce an output,
  i.e. - in other words - that the generation will actually
  terminate without an infinite recursion.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S <font color="#CC0000">::=</font> S
  <font color="#CC0000">|</font> A <font color=
  "#CC0000">;</font><br>
  A <font color="#CC0000">::=</font> B <font color=
  "#CC0000">;</font><br>
  B <font color="#CC0000">::=</font> S <font color=
  "#CC0000">|</font> A <font color="#CC0000">;</font></font><br>
  <br></code><br>
  This grammar could never produce any output, since generation,
  despite any starting non-terminal symbol, would loop forever.<br>
  Other, more tricky, cases may lead to such a subcycle - kind of a
  circuit:<br>
  <br>
  <code><font color="#996633">S <font color=
  "#CC0000">::=</font></font> a <font color="#996633"><font color=
  "#CC0000">|</font> A <font color="#CC0000">;</font><br>
  A <font color="#CC0000">::=</font> B <font color=
  "#CC0000">;</font><br>
  B <font color="#CC0000">::=</font> A <font color=
  "#CC0000">;</font></font></code><br>
  <br>
  <br>
  Although here generation may not lead to a cyclic recursion
  thanks to the terminal <code>a</code>, it is still possible for a
  non-terminating path to be entered: such cases are therefore
  signaled by an error message too.<br>
  <br>
  <br>
  <h4><a name="3.0.1.3_Unfolding_ricorsivi" id=
  "3.0.1.3_Unfolding_ricorsivi"></a> 3.0.1.3 Recursive
  unfoldings</h4>You're not allowed to prefix the unfolding
  operator&nbsp;<font color="#CC0000"><code>&gt;</code></font> (see
  section <a href="#2.0.4.1_Di_simboli_non_terminali">2.0.4.1</a>)
  to a non-terminal symbol that would cause a cyclic recursion.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#CC0000"><font color="#996633">S</font> ::=
  &gt;<font color="#996633">A</font> ;<br>
  <font color="#996633">A</font> ::= &gt;<font color=
  "#996633">B</font> ;<br>
  <font color="#996633">B</font> ::= &gt;<font color=
  "#996633">S</font> ;</font><br>
  <br></code><br>
  Such grammar would lead to an unfolding loop that would expand it
  infinitely and it therefore generates an error message.<br>
  <br>
  <br>
  <h4><a name="3.0.1.4_Epsilon-produzioni" id=
  "3.0.1.4_Epsilon-produzioni"></a> 3.0.1.4
  Epsilon-productions</h4>A grammar may satisfy the termination
  clause thanks to an epsilon-production (see section <a href=
  "#2.0.2_Epsilon">2.0.2</a>). In such case the grammar is
  considered to be correct, still it possibly produces an empty
  output.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#996633">A</font><font color=
  "#339999">.3</font> <font color="#CC0000">;</font><br>
  <br>
  <font color="#996633">A</font> <font color="#CC0000">::=</font>
  <font color="#3333FF">1:</font> a <font color="#CC0000">|</font>
  <font color="#3333FF">2:</font> b <font color=
  "#CC0000">;</font><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code><font color="#CC0000">_</font><br>
  <br></code><br>
  A destructive selection is not an error itself, since in some
  situations it might be exactly one's will (see section <a href=
  "#3.0.2.2_Potenziali_epsilon-produzioni">3.0.2.2</a>);
  nevertheless all cases where generation would lead to just
  epsilon-productions are notified by an error message.<br>
  <br>
  <br>
  <h4><a name="3.0.1.5_Ridefinizione_di_simboli_non_terminali" id=
  "3.0.1.5_Ridefinizione_di_simboli_non_terminali"></a> 3.0.1.5
  Overriding of non-terminal symbols<br></h4>A grammar is verified
  to not define the same non-terminal symbol more than once.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">A</font> <font color=
  "#CC0000">::=</font> apple <font color="#CC0000">|</font> orange
  <font color="#CC0000">|</font> banana <font color=
  "#CC0000">;</font><br>
  <font color="#996633"><br>
  A</font> <font color="#CC0000">::=</font> mandarin <font color=
  "#CC0000">|</font> melon <font color="#CC0000">;</font><br>
  <br></code><br>
  Such grammar leads to an error since <font color=
  "#996633"><code>A</code></font> is defined twice.<br>
  <br>
  <br>
  <h4><a name="3.0.1.6_Carattere_sconosciuto" id=
  "3.0.1.6_Carattere_sconosciuto"></a> 3.0.1.6 Illegal
  character</h4>Properly an error generated by the lexer in case a
  character not belonging to any known token (i.e. not defined by
  the lexical rules in section <a href=
  "#4.1.3_Regole_lessicali">4.1.3</a>) has been detected during the
  syntactical analisis phase of a source file.<br>
  <br>
  <br>
  <br>
  <h4><a name="3.0.1.7_Token_inaspettato" id=
  "3.0.1.7_Token_inaspettato"></a> 3.0.1.7 Unexpected token</h4>An
  error generated by the parser in case a valid token&nbsp;in a
  wrong position has been detected during the syntactical analisis
  phase of a source file, leading to the breaking of the
  syntactical rules in section <a href=
  "#4.1.1_Sintassi_concreta">4.1.1</a>.<br>
  <br>
  <br>
  <br>
  <br>
  <h3><a name="3.0.2_Warning" id="3.0.2_Warning"></a> 3.0.2
  Warnings<br></h3>Warnings are classified as cases that do not
  break the grammar correctness definition, still they may lead to
  unexpected results.<br>
  Warning messages thus mean not the grammar source to be
  uncorrect, indeed not robust.<br>
  A warning does not halt the program execution.<br>
  <br>
  Warnings are divided into levels, depending on their gravity: the
  lower a level, the more urgent the warnings grouped within; level
  0 contains warnings that cannot be ignored (still not being
  dangerous for the generation).<br>
  <br>
  <h4><a name="3.0.2.0_Livello_0" id="3.0.2.0_Livello_0"></a>
  3.0.2.0 Level 0</h4>There exists no warning within this group, by
  now.<br>
  <br>
  <h4><a name="3.0.2.0_Livello_1" id="3.0.2.0_Livello_1"></a>
  3.0.2.1 Level 1</h4>
  <h4><a name="3.0.2.1_Inesistenza_del_simbolo_I" id=
  "3.0.2.1_Inesistenza_del_simbolo_I"></a> 3.0.2.1 Undefined symbol
  <code>I</code><br></h4>The lack of definition for the
  non-terminal symbol&nbsp;<code>I</code> does not allow the usage
  of the program&nbsp;<code>-info</code> option.<br>
  Such symbol typically specifies an information string for the
  grammar (its author, title, etc.) and it is a good habit to
  follow such convention by properly defining it, though it is
  actually not an error to omitt it.<br>
  <br>
  <h4><a name="3.0.2.2_Potenziali_epsilon-produzioni" id=
  "3.0.2.2_Potenziali_epsilon-produzioni"></a> 3.0.2.2 Potential
  epsilon-productions<br></h4>There exist cases of a grammar not
  always generating an epsilon (see section <a href=
  "#3.0.1.4_Epsilon-produzioni">3.0.1.4</a>), but just
  possibly.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> <font color="#996633">A</font><font color=
  "#339999">.3</font> <font color="#CC0000">|</font> c <font color=
  "#CC0000">;</font><br>
  <br>
  <font color="#996633">A</font> <font color="#CC0000">::=</font>
  <font color="#3333FF">1:</font> a <font color="#CC0000">|</font>
  <font color="#3333FF">2:</font> b <font color=
  "#CC0000">;</font></code><code><br>
  <br></code><br>
  <samp><b>PRODUCES</b></samp><br>
  <br>
  <code>c<br>
  <font color="#CC0000">_</font><br>
  <br></code><br>
  Such case are not errors and are notified by a warning
  message.<br>
  <br>
  <br>
  <h4><a name="3.0.2.0_Livello_2" id="3.0.2.0_Livello_2"></a>
  3.0.2.1 Level 2</h4>
  <h4><a name="3.0.2.2_Permutazione_inutile" id=
  "3.0.2.2_Permutazione_inutile"></a> 3.0.2.3 Useless
  permutation</h4>In case only one permutable subproduction appears
  within a sequence (see section <a href=
  "#2.0.7_Permutazioni">2.0.7</a>), no permutation is actually
  performed for obvious reasons.<br>
  <br>
  <samp><b>EXAMPLE</b></samp><br>
  <br>
  <code><font color="#996633">S</font> <font color=
  "#CC0000">::=</font> a <font color=
  "#CC0000">{</font>b<font color="#CC0000">}</font> c <font color=
  "#CC0000">;</font></code><br>
  <br>
  <br>
  Though such case actually is not an error, just a low-gravity
  warning message is output.<br>
  <br>
  <br>
  <h4><a name="3.0.2.2.2_Potenziale_ricorsione_ciclica" id=
  "3.0.2.2.2_Potenziale_ricorsione_ciclica"></a> 3.0.2.2.2
  Potential cyclic recursion</h4>Recursion is rather a powerful and
  useful tool, probably quite frequently used in complex grammars.
  Though all non-termination cases caused by a abuse of recursion
  are trapped by the grammar checker (see section <a href=
  "#3.0.1.2_Ricorsioni_cicliche_e">3.0.1.2</a>), on the other hand,
  formally legal recursions may be enough tangled to&nbsp; slow
  generation down for a sensible amount.<br>
  Every single recursion case may therefore be signaled a
  low-gravity warning, somehow in order to aid the user at
  localizing unwanted recursions.<br>
  <br>
  <br>
  <br>
  <h2><a name="4.0_Appendice" id="4.0_Appendice"></a> 4.0
  Appendix</h2>
  <h3><br></h3>
  <h3><a name="4.1.1_Sintassi_concreta" id=
  "4.1.1_Sintassi_concreta"></a> 4.1.1 Concrete
  syntax<br></h3><i>Type-2</i> syntax (in <i>BNF</i> notation) of
  the grammar definition language interpreted by <i>PolyGen</i> and
  described in this document follows below.<br>
  Non-terminal symbols bound to productions are capitalized;
  non-terminal symbols bound to regular expressions begin with a
  capital letter (see section <a href=
  "#4.1.3_Regole_lessicali">4.1.3</a>); terminal symbols are
  quoted; <code>S</code> is the starting non-terminal symbol.<br>
  <br>
  <br>
  <code>S &nbsp; &nbsp; &nbsp;::= DEF<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; DEF S<br>
  <br>
  DEF &nbsp; &nbsp;::= Nonterm "::=" PRODS ";"<br>
  <br>
  PRODS &nbsp;::= PROD<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; PROD "|" PRODS<br>
  <br>
  PROD &nbsp; ::= SEQ<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;MODIF SEQ<br>
  <br>
  MODIF &nbsp;::= "+"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "-"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "+" MODIF<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "-" MODIF<br>
  <br>
  LABELS ::= LABEL<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;LABEL "|" LABELS<br>
  <br>
  LABEL &nbsp;::= Label<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;MODIF Label<br>
  <br>
  SEQ &nbsp; &nbsp;::= ATOMS<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; Label ":" ATOMS<br>
  <br>
  ATOMS&nbsp; ::= ATOM<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; ATOM ATOMS<br>
  <br>
  ATOM &nbsp; ::= Term<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "^"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "_"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;"\"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | UNFOLDABLE<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;"&gt;" UNFOLDABLE<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;"&lt;" UNFOLDABLE<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; ATOM "."<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; ATOM DotLabel<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;ATOM ".(" LABELS
  ")"</code><code><br>
  <br>
  UNFOLDABLE ::= Nonterm<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp;&nbsp;
  "(" PRODS ")"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp;&nbsp;&nbsp; "[" PRODS
  "]"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp;&nbsp; "{" PRODS
  "}"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp;"&gt;&gt;"
  PRODS "&lt;&lt;"</code><code><br>
  <br></code><br>
  <br>
  <h3><a name="4.1.2_Sintassi_astratta" id=
  "4.1.2_Sintassi_astratta"></a> 4.1.2 Abstract syntax<br></h3>For
  the sake of completeness, the abstract syntax of the language
  interpreted by <i>PolyGen</i> follows cleared from syntactical
  sugars and terms involved in preprocessing only.<br>
  <br>
  <br>
  <code>S &nbsp; &nbsp; &nbsp;::= DEF<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; DEF S<br>
  <br>
  DEF &nbsp; &nbsp;::= Nonterm "::=" PRODS ";"<br>
  <br>
  PRODS &nbsp;::= SEQ<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; SEQ "|" PRODS<br>
  <br>
  SEQ &nbsp; &nbsp;::= ATOMS<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; Label ":" ATOMS<br>
  <br>
  ATOMS&nbsp; ::= ATOM<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; ATOM ATOMS<br>
  <br>
  ATOM &nbsp; ::= Nonterm<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; Term<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "^"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "_"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; "(" PRODS ")"<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; ATOM "."<br>
  &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; ATOM
  DotLabel</code><code><br></code><br>
  <br>
  <br>
  <h3><a name="4.1.3_Regole_lessicali" id=
  "4.1.3_Regole_lessicali"></a> 4.1.3 Lexical
  rules<br></h3><i>Type-3</i> lexical rules (in regular expression
  notation) follow.<br>
  <br>
  <br>
  <code>Term &nbsp; &nbsp; ::= [a-z 0-9 , '][a-z A-Z 0-9 , ']*<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; " [A-Z a-z 0-9 ( ) _ -
  ? . , ! : \ &amp; # + * / % $ � [ ] { } ~ @ ; : | &lt; &gt; = ^ '
  \ "]* "<br>
  <br>
  Nonterm &nbsp;::= [A-Z][A-Z a-z 0-9 _]*<br>
  <br>
  Label &nbsp; &nbsp;::= [A-Z a-z 0-9 _]+<br>
  <br>
  DotLabel ::= . Label<br>
  <br></code><br>
  Notice that the white space character can be quoted as a terminal
  symbol too.<br>
  <br>
  <br>
  <br>
  <h3><a name="4.1.4_Caratteri_escape" id=
  "4.1.4_Caratteri_escape"></a> 4.1.4 Escape
  sequences<br></h3>Regular expression&nbsp;<code>Nonterm</code> in
  section <a href="#4.1.3_Regole_lessicali">4.1.3</a> recognizes
  the backslash character within quotes. A terminal symbol is
  therefore allowed to contain any escape sequence among the
  following:<br>
  <br>
  <br>
  <table border="1" width="30%" cellpadding="2" cellspacing="2"
  bgcolor="#CCCCCC">
    <tbody>
      <tr>
        <td>\\</td>
        <td>backslash</td>
      </tr>
      <tr>
        <td>\"</td>
        <td>quote<br></td>
      </tr>
      <tr>
        <td>\n</td>
        <td>new line</td>
      </tr>
      <tr>
        <td>\r</td>
        <td>carriage return</td>
      </tr>
      <tr>
        <td>\b</td>
        <td>backspace</td>
      </tr>
      <tr>
        <td>\t</td>
        <td>tab</td>
      </tr>
      <tr>
        <td valign="top">\<i>xyz</i></td>
        <td valign="top">ASCII decimal code <i>xyz</i><br></td>
      </tr>
    </tbody>
  </table><br>
  <br>
  <br>
  <br>
  <h3><a name="4.1.5_Regole_di_traduzione" id=
  "4.1.5_Regole_di_traduzione"></a> 4.1.5 Translation rules</h3>As
  a formal reference, translation rules from concrete syntax to
  abstract syntax together with proper precedence (where the least
  number stands for the highest priority) follow. They therefore
  refer to the operations performed by either the parser (in case
  of syntactical sugars) or the preprocessor (otherwise).<br>
  <br>
  <code><br></code>
  <table cellpadding="2" cellspacing="2" border="1" width="100%">
    <tbody>
      <tr>
        <td valign="top"><br></td>
        <td valign="top" align="center"><b>concrete
        syntax</b><br></td>
        <td valign="top" align="center"><b>abstract
        syntax</b><br></td>
      </tr>
      <tr>
        <td valign="top"><br>
        <b>1</b><br></td>
        <td valign="top"><code><big>A<font color=
        "#339999">.(</font></big></code><code><font color=
        "#CC0000">+</font></code><code><b><sup>(a<sub>1</sub>)</sup></b><font color="#CC0000">-</font><b><sup>(b<sub>1</sub>)</sup></b></code><code><big><font color="#339999">l<sub>1</sub>|...|</font></big></code><code><font color="#CC0000">+</font><b><sup>(a<sub>n</sub>)</sup></b><font color="#CC0000">-</font><b><sup>(b<sub>n</sub>)</sup></b></code><code><big><font color="#339999">l<sub>n</sub>)</font></big></code><br>
        </td>
        <td valign="top"><code><big><font color=
        "#CC0000">(</font>A<font color=
        "#339999">.l<sub>1</sub></font>&nbsp;</big></code><code><big><font color="#CC0000">|</font></big></code><code><big><b><small><sub>(1)</sub></small></b>
        ...&nbsp;</big></code><code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(w</sub><sub>1)</sub></small></b></big></code>
        <code><big>A<font color=
        "#339999">.l<sub>1</sub></font></big></code>
        <code><big><font color="#CC0000">|</font></big></code>
        <code><big>...&nbsp;<font color="#CC0000">|</font>
        A<font color="#339999">.l<sub>n</sub></font></big></code>
        <code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(1)</sub></small></b>
        ...&nbsp;</big></code><code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(wn)</sub></small></b></big></code>
        <code><big>A<font color=
        "#339999">.l<sub>n</sub></font></big></code><code><big><font color="#CC0000">)</font></big></code><br>

        <br>
        <code><big><i>where</i> <b>w<sub>i</sub> = a<sub>i</sub> -
        b<sub>i</sub> -</b></big></code> <code><big><b>min</b>
        <b>{a<sub>1</sub>-b<sub>1</sub> ...</b></big></code>
        <code><big><b>a<sub>n</sub>-b<sub>n</sub></b></big></code><code><big><b>}</b></big></code><br>
        </td>
      </tr>
      <tr>
        <td valign="top"><br>
        <b>2</b><br></td>
        <td valign="top"><code><font color=
        "#CC0000">+</font><b><sup>(a<sub>1</sub>)</sup></b><font color="#CC0000">-</font><b><sup>(b<sub>1</sub>)</sup></b></code>
        <code><big>P<sub>1</sub></big> <big><font color=
        "#CC0000">|</font></big>
        <big>...&nbsp;</big><big><font color=
        "#CC0000">|</font></big></code><code><font color=
        "#CC0000">+</font><b><sup>(a<sub>n</sub>)</sup></b><font color="#CC0000">-</font><b><sup>(b<sub>n</sub>)</sup></b></code>
        <code><big>P<sub>n</sub></big></code><br></td>
        <td valign="top">
        <code><big>P<sub>1</sub>&nbsp;</big></code><code><big><font color="#CC0000">|</font></big></code><code><big><b><small><sub>(1)</sub></small></b>
        ...&nbsp;</big></code><code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(w</sub><sub>1)</sub></small></b>
        P<sub>1</sub>&nbsp;</big></code><code><big><font color=
        "#CC0000">|</font></big></code>
        <code><big>...&nbsp;</big></code><code><big><font color=
        "#CC0000">|</font></big></code>
        <code><big>P<sub>n</sub>&nbsp;</big></code><code><big><font color="#CC0000">|</font></big></code><code><big><b><small><sub>(1)</sub></small></b>
        ...&nbsp;</big></code><code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(wn)</sub></small></b>
        P<sub>n</sub></big></code><br>
        <br>
        <code><big><i>where</i> <b>w<sub>i</sub> = a<sub>i</sub> -
        b<sub>i</sub> -</b></big></code> <code><big><b>min</b>
        <b>{a<sub>1</sub>-b<sub>1</sub> ...</b></big></code>
        <code><big><b>a<sub>n</sub>-b<sub>n</sub></b></big></code><code><big><b>}</b></big></code><br>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>3</b><br></td>
        <td valign="top"><code><big><font color=
        "#CC0000">[</font></big></code><code><big>P</big></code><code><big><font color="#CC0000">]</font></big></code><br>
        </td>
        <td valign="top"><code><big><font color=
        "#CC0000">(</font><font color="#CC0000">_
        |</font></big></code> <code><big><font color=
        "#CC0000">(</font></big></code><code><big>P</big></code><code><big><font color="#CC0000">))</font></big></code><br>
        </td>
      </tr>
      <tr>
        <td valign="top"><br>
        <b>4</b><br></td>
        <td valign="top"><code><big><font color=
        "#CC0000">&gt;&gt;</font></big></code>
        <code><big>P</big></code> <code><big><font color=
        "#CC0000">&lt;&lt;</font></big></code><br></td>
        <td valign="top"><code><big><font color=
        "#CC0000">(</font></big></code><code><big>P'</big></code><code><big><font color="#CC0000">)</font></big></code><br>

        <br>
        <i><big><code>where P' is isomorph to P where
        <b>unfoldable</b> atoms are unfolded</code></big></i></td>
      </tr>
      <tr>
        <td valign="top"><br>
        <br>
        <br>
        <b>5</b><br></td>
        <td valign="top"><code><big>P<sub>1</sub> <font color=
        "#CC0000">|</font> ... <font color=
        "#CC0000">|</font>&nbsp;</big></code><code><big>A<sub>1</sub></big></code>
        <code><big><font color=
        "#CC0000">{</font>Q<sub>1</sub><font color=
        "#CC0000">}</font><font color=
        "#339999">.<small><code><big><font color=
        "#339999"><small><code><big><font color=
        "#339999">l<sub>1</sub></font></big></code></small></font></big></code></small></font></big></code>
        <code><big>...&nbsp;</big></code><code><big>A<sub>n</sub></big></code>
        <code><big><font color=
        "#CC0000">{</font></big></code><code><big>Q</big></code><code><big><sub>n</sub></big></code><code><big><font color="#CC0000">}</font><font color="#339999">.<small><code><big><font color="#339999">l<sub>n</sub></font></big></code></small></font></big></code>
        <code><big><font color="#CC0000">|</font></big></code>
        <code><big>... <font color="#CC0000">|</font>
        P<sub>n</sub></big></code><br></td>
        <td valign="top"><code><big>P<sub>1</sub> <font color=
        "#CC0000">|</font> ... <font color="#CC0000">|</font>
        A<sub>1</sub> <font color=
        "#CC0000">(</font>Q<sup>1</sup><sub>1</sub></big></code><code><big><font color="#CC0000">)</font></big></code><code><big><font color="#339999">.<small><code><big><font color="#339999">l<sub>1</sub></font></big></code></small></font></big></code>
        <code><big>...
        A<sub>n</sub>&nbsp;</big></code><code><big><font color=
        "#CC0000">(</font></big></code><code><big>Q<sup>1</sup></big></code><code><big><sub>n</sub></big></code><code><big><font color="#CC0000">)</font></big></code><code><big>.</big></code><code><big><font color="#339999">l<sub>n</sub></font></big></code>
        <code><big><font color="#CC0000"><br>
        &nbsp; &nbsp;</font></big></code><code><big><font color=
        "#CC0000">|</font> ...</big></code> <code><big><font color=
        "#CC0000">|</font>&nbsp;<small><code><big>A<sub>1</sub>
        <font color=
        "#CC0000">(</font>Q<sup>n!</sup><sub>n</sub></big></code><code><big><font color="#CC0000">)</font></big></code><code><big><font color="#339999">.<small><code><big><font color="#339999">l<sub>1</sub></font></big></code></small></font></big></code>
        <code><big>...
        A<sub>n</sub>&nbsp;</big></code><code><big><font color=
        "#CC0000">(</font></big></code><code><big>Q<sup>n!</sup></big></code><code><big><sub>n</sub></big></code><code><big><font color="#CC0000">)</font></big></code><code><big>.</big></code><code><big><font color="#339999">l<sub>n</sub></font></big></code></small></big></code>
        <code><big><font color="#CC0000">|</font></big></code>
        <code><big>... <font color="#CC0000">|</font>
        P<sub>n</sub></big></code><br>
        <br>
        <big><code><i>where</i></code>
        <code><big>Q<sup>j</sup><sub>i</sub></big></code>
        <code><i>is the</i></code> <code>i-<i>th element of
        the</i></code> <code>j-<i>th <b>permutation<br></b>
        of</i></code>
        <code><big>Q<sub>1</sub></big>..</code><code><big>Q</big></code><code><big><sub>n</sub></big><i>(with</i></code>
        <code>i = 1..n, j = 1..n!<i>)</i></code></big><br></td>
      </tr>
      <tr>
        <td valign="top"><b>6</b><br></td>
        <td valign="top"><code><big>P<sub>1</sub> <font color=
        "#CC0000">|</font> ...&nbsp;<font color="#CC0000">|</font>
        <font color="#3333FF">L:</font> A <font color=
        "#CC0000">&gt;(</font>Q<sub>1</sub>&nbsp;<font color=
        "#CC0000">|</font> ...&nbsp;<font color="#CC0000">|</font>
        Q<sub>m</sub><font color="#CC0000">)</font><font color=
        "#339999">.l</font> B&nbsp;<font color="#CC0000">|</font>
        ...&nbsp;<font color="#CC0000">|</font>
        P<sub>n</sub><br></big></code></td>
        <td valign="top"><code><big>P<sub>1</sub>&nbsp;<font color=
        "#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;<font color="#3333FF">L:</font> A
        <font color="#CC0000">(</font>Q<sub>1</sub><font color=
        "#CC0000">)</font><font color="#339999">.l</font>
        B&nbsp;<font color="#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;<font color="#3333FF">L:</font> A
        <font color="#CC0000">(</font>Q<sub>m</sub><font color=
        "#CC0000">)</font><font color="#339999">.l</font>
        B&nbsp;<font color="#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;P<sub>n</sub><br></big></code></td>
      </tr>
      <tr>
        <td valign="top"><br>
        <b>6</b><br></td>
        <td valign="top"><code><big>P<sub>1</sub> <font color=
        "#CC0000">|</font> ...&nbsp;<font color="#CC0000">|</font>
        <font color="#3333FF">L:</font> A <font color=
        "#CC0000">&gt;</font><font color=
        "#996633">X</font><font color="#339999">.l</font>
        B&nbsp;<font color="#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font> P<sub>n</sub><br>
        <br>
        <i>where</i> <font color="#996633">X</font> <font color=
        "#CC0000">::=</font>&nbsp;Q<sub>1</sub>&nbsp;<font color=
        "#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;Q<sub>m</sub><br></big></code></td>
        <td valign="top"><code><big>P<sub>1</sub>&nbsp;<font color=
        "#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;<font color="#3333FF">L:</font> A
        <font color="#CC0000">(</font>Q<sub>1</sub><font color=
        "#CC0000">)</font><font color="#339999">.l</font>
        B&nbsp;<font color="#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;<font color="#3333FF">L:</font> A
        <font color="#CC0000">(</font>Q<sub>m</sub><font color=
        "#CC0000">)</font><font color="#339999">.l</font>
        B&nbsp;<font color="#CC0000">|</font> ...&nbsp;<font color=
        "#CC0000">|</font>&nbsp;P<sub>n</sub><br></big></code></td>
      </tr>
    </tbody>
  </table><br>
  <br>
  Where the following notational conventions hold:<br>
  <br>
  <br>
  <table border="1" width="60%" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td><code><big>P</big></code><code>,</code>
        <code><big>Q</big></code></td>
        <td>productions or series of productions</td>
      </tr>
      <tr>
        <td><big><code>A</code></big><code>,</code>
        <big><code>B</code></big></td>
        <td>atoms o atom (sub)sequences</td>
      </tr>
      <tr>
        <td><code><big><font color=
        "#3333FF">L</font></big></code><code>,</code>
        <code><big><font color="#339999">l</font></big></code></td>
        <td>labels</td>
      </tr>
      <tr>
        <td valign="top"><code><big><font color=
        "#996633">X</font></big></code><code>,</code>
        <code><big><font color=
        "#996633">Y</font></big></code><br></td>
        <td valign="top">non-terminali symbols<br></td>
      </tr>
      <tr>
        <td><code><font color=
        "#CC0000">+</font><b><sup>(n)</sup></b><font color=
        "#CC0000">-</font><b><sup>(m)</sup></b></code></td>
        <td>juxtaposition of <b>n</b> and <b>m</b>,
        respectively<b>,</b> <font color="#CC0000">+</font>
        and&nbsp;<code><font color="#CC0000">-</font></code>
        operators</td>
      </tr>
      <tr>
        <td><code><big>P</big></code> <code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(1)</sub></small></b>
        ...</big></code> <code><big><font color=
        "#CC0000">|</font></big></code><code><big><b><small><sub>(n)</sub></small></b>
        P</big></code></td>
        <td><b>n</b>-lengthened series of productions P</td>
      </tr>
    </tbody>
  </table><br>
</body>
</html>
